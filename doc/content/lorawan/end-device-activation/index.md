---
title: Message Types
section: Fundamental
---

<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 0; ALERTS: 4.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>



## End Device Activation

In this chapter, you will learn how to activate and personalize an end device with a LoRaWAN network. Every end device should be registered with a network before sending and receiving messages. This registering procedure is known as “activation”. Currently, there are two activation methods available:



*   **Over-The-Air-Activation (OTAA) **- Over-The-Air-Activation is the most secure activation method for end devices. This is also known as the “**join procedure**”.
*   **Activation By Personalization (ABP)** - Less secure than the OTAA and bypasses the join procedure. The end device is preprogrammed with keys and tied to a specific network.

The join procedure for LoRaWAN 1.0.x and 1.1 is slightly different. The following two sections describe the join procedure for LoRaWAN 1.0.x and 1.1 separately.


## Over The Air Activation in LoRaWAN 1.0.x

In **LoRaWAN 1.0.x**, the join procedure involves **two** **MAC messages** exchanged between the **end device** and the **network server**. They are,



*   Join-request.
*   Join-accept.

**<span style="text-decoration:underline;">Before activation:</span>**

Before activation, the **AppEUI**, **DevEUI**, and **AppKey **should be stored in the end device. The **AppKey **is an AES-128 bit secret key known as a **root key**. The same **AppKey **should be **provisioned **onto the **Network **where the end device is going to register. The **AppEUI **and **DevEUI **are not secret and are visible to everyone.

**_NOTE: The AppKey is never sent over the network. _**

**<span style="text-decoration:underline;">OTAA Message Flow:</span>**

The steps below describe the message flow of the Over-The-Air-Activation (OTAA).



<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image1.png "image_tooltip")


**Step 1:**

The **Join-request** message is always **initiated **and transmitted by the **end device**. The **join-request** message consists of the following three fields.



*   **DevEUI** – 64-bit (8-byte) globally unique end-device identifier in IEEE EUI64 address space.
*   **AppEUI** – 64-bit (8-byte) globally unique identifier in IEEE EUI64 address space that uniquely identifies the **entity **able to process the **join-request** frame. This is also known as the application identifier.
*   **DevNonce** – this is a unique, random, 2-bytes value generated by the end device. The network server uses **DevNonce **to keep track of each end-device. The **DevNonce **value is used to **_prevent _replay attacks**. If the end device sends a join-request with a previously used DevNonce, the network server rejects the join request and does not allow the end device to register with the network.

**_NOTE: Learning about replay attacks is beyond the scope of The Things Fundamentals certification._**

The structure of the** join-request** message is shown in the following figure.


<table>
  <tr>
   <td>8 bytes
   </td>
   <td>8 bytes
   </td>
   <td>2 bytes
   </td>
  </tr>
  <tr>
   <td>AppEUI
   </td>
   <td>DevEUI
   </td>
   <td>DevNonce
   </td>
  </tr>
</table>


_Figure: Join-request message in LoRaWAN 1.0.x_

The **Message Integrity Code (MIC)** is calculated over all the fields of the join-request frame using the **AppKey**.

_cmac = aes128_cmac(**AppKey**, MHDR | AppEUI | DevEUI | DevNonce)_

_MIC<sub>1</sub> = cmac[0…3]_

The calculated Message Integrity Code (MIC) is added to the end of the message. 


<table>
  <tr>
   <td>1 byte
   </td>
   <td>8 bytes
   </td>
   <td>8 bytes
   </td>
   <td>2 bytes
   </td>
   <td>4 bytes
   </td>
  </tr>
  <tr>
   <td>MHDR
   </td>
   <td>AppEUI
   </td>
   <td>DevEUI
   </td>
   <td>DevNonce
   </td>
   <td>MIC
   </td>
  </tr>
</table>


_Figure: PHYPayload structure of the Join-request message_

**_NOTE: _**



*   _The **AppKey **is not sent with the **Join-request **message. It is used to calculate the **MIC **only._
*   _The **Join-request** message is not encrypted and sent as plain text._

The Join-request message can be transmitted using **any data rate** and using **one of the specified join channels**. These join channels are region-specific. For example, in Europe an end device can transmit the join-request message by randomly choosing among 868.10 MHz, 868.30 MHz, or 868.50 MHz. The join-request message travels through one or more gateways that simply relay the message back to the network server.

**_NOTE: No response is given to the end-device if the Join-request is not accepted. _**

**_<span style="text-decoration:underline;">Step 2:</span>_**

Now the **Join-request **message has been received by the **Network Server**. If the **end device **is permitted to join with the network the network server will respond to the **Join-request **message with a **Join-accept** message.

The **Join-accept** message consists of the following fields.



*   **AppNonce **– this is a random value or some form of unique ID provided by the network server. The AppNonce is used by the end device to derive the two session keys, **AppSKey **and **NwkSKey**.
*   **NetID **– consists of the network ID (the 7 least significant bits) and the remaining 17 most significant bits are chosen by the network operator.
*   **DevAddr** – this is the 32-bit device address assigned by the network server. Consists of NwkID and NwkAddress. The device address is unique within the current network.
*   **DLSettings** – this is a 1-byte sized field consisting of downlink settings which the end device should use.
*   **RxDelay** – the delay between TX and RX
*   **CFList** – contains the optional list of channel frequencies to be used for the end device

The following figure shows the **join-accept** message with all the above-generated values.


<table>
  <tr>
   <td>3 bytes
   </td>
   <td>3 bytes
   </td>
   <td>4 bytes
   </td>
   <td>1 byte
   </td>
   <td>1 byte
   </td>
   <td>(16 bytes) Optional
   </td>
  </tr>
  <tr>
   <td>AppNonce
   </td>
   <td>NetID
   </td>
   <td>DevAddr
   </td>
   <td>DLSettings
   </td>
   <td>RxDelay
   </td>
   <td>CFList
   </td>
  </tr>
  <tr>
   <td colspan="3" >
   </td>
   <td colspan="3" >Network settings
   </td>
  </tr>
</table>


_Figure: Structure of the join-accept message._

The Message Integrity Code (MIC) is calculated using the **AppKey** over all the fields of the join-accept message as follows.

NOTE: The MAC Header (MHDR) is added before calculating the MIC.

_cmac = aes128_cmac(**AppKey**, MHDR | AppNonce | NetID | DevAddr | DLSettings | RxDelay | CFList)_

_MIC = cmac[0…3]_

The calculated MIC is added to the end of the Join-accept message itself. The resulting frame is shown below.


<table>
  <tr>
   <td>1 byte
   </td>
   <td>3 bytes
   </td>
   <td>3 bytes
   </td>
   <td>4 bytes
   </td>
   <td>1 byte
   </td>
   <td>1 byte
   </td>
   <td>(16 bytes) Optional
   </td>
   <td>4 bytes
   </td>
  </tr>
  <tr>
   <td>MHDR
   </td>
   <td>AppNonce
   </td>
   <td>NetID
   </td>
   <td>DevAddr
   </td>
   <td>DLSettings
   </td>
   <td>RxDelay
   </td>
   <td>CFList
   </td>
   <td>MIC
   </td>
  </tr>
</table>


The **Network Server** uses an AES decrypt operation in ECB mode to encrypt the **Join-accept** message so that the **end-device** can use an AES encrypt operation to decrypt the message. 

The** Join-accept** message itself is encrypted with the **AppKey** as follows.

_aes128_decrypt(**AppKey**, AppNonce | NetID | DevAddr | DLSettings | RxDelay | CFList | MIC)_

**<span style="text-decoration:underline;">Step 3:</span>**

The **Network Server** sends the encrypted **Join-accept** message back to the **end device**. The Join-accept message is sent as a normal downlink and uses the following delays to open the receive windows.



*   JOIN_ACCEPT_DELAY1 - default value is 5 seconds
*   JOIN_ACCEPT_DELAY2 - default value is 6 seconds

**<span style="text-decoration:underline;">Step 4:</span>**

The **Network Server** sends the **AppSKey **to the **Application Server**.

**<span style="text-decoration:underline;">Step 5:</span>**

The end device uses the **AppNonce **to derive the two session keys **Network Session Key** (**NwkSKey**) and the **Application Session Key** (**AppSKey**). The keys are calculated as follows by decrypting the Join-accept using the AES encrypt operation. 

**_NwkSKey = aes128_encrypt(AppKey, 0x01 | AppNonce | NetID | DevNonce | pad_16 )_**

**_AppSKey = aes128_encrypt(AppKey, 0x02 | AppNonce | NetID | DevNonce | pad_16 )_**

**<span style="text-decoration:underline;">After Activation:</span>**

After activation, the following additional information is stored in the end device.



*   **DevAddr **- The DevAddr is allocated by the Network Server of the end-device. It is a 32-bit device address that identifies the end-device within the current network. 
*   **NwkSKey **- The **NwkSKey **is used by the end device and network server to calculate and verify the Message Integrity Code (MIC) of all data messages to ensure data integrity. The **NwkSKey **is also used to encrypt and decrypt the payloads with MAC commands.
*   **AppSKey **- The AppSKey is used to secure end-to-end communications between the end device and the application server by encrypting the payloads with application-specific data


## Over-The-Air-Activation in LoRaWAN 1.1

In **LoRaWAN 1.1**, the join procedure involves **two** **MAC messages** exchanged between the **end device** and the **Join Server**. They are,



*   Join-request.
*   Join-accept.

**<span style="text-decoration:underline;">Before the activation:</span>**

Before the activation, **JoinEUI**, **DevEUI**, **AppKey**, and **NwkKey **should be stored in the end device. The **AppKey **and **NwkKey **are AES-128 bit secret keys known as **root keys**. The matching **AppKey, NwkKey, **and **DevEUI **should be **provisioned **onto the **Join Server **that can assist in the processing of the **Join procedure** and the session keys derivation. **JoinEUI **and **DevEUI **are not secret and visible to everyone.

**_NOTE: The AppKey and NwkKey are never sent over the network. _**

**<span style="text-decoration:underline;">OTAA Message Flow:</span>**

The steps below describe the message flow of the Over-The-Air-Activation (OTAA).



<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image2.png "image_tooltip")


_Figure: Message flow for Over-The-Air-Activation (OTAA)_

**Step 1:**

The **Join-request** message is always **initiated **and transmitted by the **end device**. The **Join-request** message consists of the following three fields.



*   **DevEUI** – is a 64-bit (8-bytes) global **end-device ID** in IEEE EUI64 address space that uniquely identifies the **end-device**.
*   **JoinEUI** – is a 64-bit (8-bytes) global** application ID** in IEEE EUI64 address space that uniquely identifies the **Join Server** that can assist in the processing of the Join procedure and the session keys derivation.
*   **DevNonce** – this is a 2-bytes counter, starting at 0 when the device is initially powered up and incremented with every **Join-request**. The DevNonce value is used to prevent **replay attacks**.

**_NOTE: _**



*   _Learning about **replay attacks** is beyond the scope of **The Things Fundamentals** certification._
*   _In LoRaWAN 1.1 **AppEUI **is replaced with the **JoinEUI**._
*   _The procedure for joining a LoRaWAN 1.0 end device with the LoRaWAN 1.1 network is also beyond the scope of The Things Fundamentals certification._
*   _Rejoin-request messages will be covered in The Things Advanced certification._

The structure of the** Join-request** message is shown in the following figure.


<table>
  <tr>
   <td>8 bytes
   </td>
   <td>8 bytes
   </td>
   <td>2 bytes
   </td>
  </tr>
  <tr>
   <td>JoinEUI
   </td>
   <td>DevEUI
   </td>
   <td>DevNonce
   </td>
  </tr>
</table>


_Figure: Fields of the join-request message in LoRaWAN 1.1_

The **Message Integrity Code (MIC)** is calculated over all the fields of the **Join-request **frame using the **NwkKey**.

_cmac = aes128_cmac(**NwkKey**, MHDR | JoinEUI | DevEUI | DevNonce)_

_MIC<sub>1</sub> = cmac[0…3]_

The calculated **Message Integrity Code (MIC)** is added to the end of the **Join-request **message. The resulting frame is known as the **PHYPayload**. 


<table>
  <tr>
   <td>1 byte
   </td>
   <td>8 bytes
   </td>
   <td>8 bytes
   </td>
   <td>2 bytes
   </td>
   <td>4 bytes
   </td>
  </tr>
  <tr>
   <td>MHDR
   </td>
   <td>JoinEUI
   </td>
   <td>DevEUI
   </td>
   <td>DevNonce
   </td>
   <td>MIC
   </td>
  </tr>
</table>


_Figure: PHYPayload of the join-request message_

**_NOTE: _**



*   _The **NwkKey **is not sent with the **Join-request **message. It is used to calculate the **MIC **only._
*   _The **Join-request** message is not encrypted and sent as plain text._

Finally, the end-device **transmits **the **Join-request **message. The Join-request message can be transmitted using **any data rate** and using **one of the specified join channels**. These join channels are region-specific, for example, in Europe an end device can transmit the join-request message by randomly choosing among 868.10 MHz, 868.30 MHz, or 868.50 MHz. The join-request message travels through one or more gateways that simply relay the message back to the network server.

**_NOTE: No response is given to the end-device if the Join-request is not accepted. _**

**Step 2:**

The **Network Server** uses DNS to look up the IP address of the **Join Server** based on the **JoinEUI **in the received **join-request** message.

**Step 3:**

If DNS lookup succeeds, the **Network Server** sends a **JoinReq **message (backend message) to the **Join Server**. This message contains the following:



    *   PHYPayload of the join-request message
    *   MAC version
    *   DevEUI
    *   DevAddr
    *   DLSettings
    *   RxDelay
    *   CFList

**Step 4:**

The **Join Server** processes the **Join-request** message and sends the **JoinAns** message (this is also a backend message) to the **Network Server**. If successful the **JoinAns **message contains the following:



*   PHYPayload with Join-accept message
*   Network session keys 
    *   Serving Network session integrity key (SNwkSIntKey)
    *   Forwarding Network session integrity key (FNwkSIntKey)
    *   Network session encryption key (NwkSEncKey)
*   Encrypted AppSKey (network server can't read this)

<table>
  <tr>
   <td>
1 byte
   </td>
   <td>3 bytes
   </td>
   <td>3 bytes
   </td>
   <td>4 bytes
   </td>
   <td>1 byte
   </td>
   <td>1 byte
   </td>
   <td>(16 bytes) Optional
   </td>
   <td>4 bytes
   </td>
  </tr>
  <tr>
   <td>MHDR
   </td>
   <td>JoinNonce
   </td>
   <td>NetID
   </td>
   <td>DevAddr
   </td>
   <td>DLSettings
   </td>
   <td>RxDelay
   </td>
   <td>CFList
   </td>
   <td>MIC
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td colspan="3" >Network settings
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td colspan="6" >Join-accept message
   </td>
   <td>
   </td>
  </tr>
</table>


_Figure: PHYPayload of the Join-accept message_

The **Join-accept **message is encrypted with the **NwkKey **as follows: 

_aes128_decrypt(**NwkKey**, JoinNonce | NetID | DevAddr | DLSettings | 1623 RxDelay | CFList | MIC)._

NOTE: The join-accept message itself is encrypted with the **NwkKey.** The **Join Server** uses an AES decrypt operation in ECB mode to encrypt the **join-accept** message so that the **end-device** can use an AES encrypt operation to decrypt the message. This way an end-device only has to implement AES encrypt but not AES decrypt.

**Step 5:**

The **Network Server **forwards the received PHYPayload with the **Join-accept** message to the **end-device** if the received **JoinAns **message indicates success. The Join-accept message is sent as a normal downlink and uses the following delays to open the receive windows.



*   JOIN_ACCEPT_DELAY1 - default value is 5 seconds
*   JOIN_ACCEPT_DELAY2 - default value is 6 seconds

The **end-device **calculates the MIC as follows:

_cmac = aes128_cmac(**JSIntKey**, **0xFF **| JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList )_

_MIC = cmac[0..3]_

The **end-device **generates the **network session keys** and **AppSKey **as follows.

The **AppSKey **is derived from the **AppKey**:

**_AppSKey = aes128_encrypt(AppKey, 0x02 | JoinNonce | JoinEUI| DevNonce | pad_16)_**

The **FNwkSIntKey**, **SNwkSIntKey, **and **NwkSEncKey **are derived from the **NwkKey**:

**_FNwkSIntKey = aes128_encrypt(NwkKey, 0x01 | JoinNonce | JoinEUI | DevNonce | pad_16 )_**

**_SNwkSIntKey = aes128_encrypt(NwkKey, 0x03 | JoinNonce | JoinEUI | DevNonce | pad_16)_**

**_NwkSEncKey = aes128_encrypt(NwkKey, 0x04 | JoinNonce | JoinEUI | DevNonce | pad_16_**

**Step 6:**

When the Network receives an uplink packet from the end-device, the **Network Server** will send the **DevEUI **and encrypted **AppSKey** along with the **application payload** to the **Application Server**. 

**Step 7:**

When the **Application Server** receives the encrypted **AppSKey **along with the application payload, the **Application Server** will decrypt the **AppSKey **using a secret key shared between the **Join Server** and the **Application Server**, and use the **AppSKey **to decrypt the received payload. If the encrypted **AppSKey **is not made available by the **Network Server**, then the **Application Server** will proceed to **Step 8**.

**Step 8:**

In this alternative step, the **Application Server** requests the **AppSKey **directly from the **Join Server**. The **Application Server** will request the **AppSKey **identified by the **DevEUI **of the end device from the **Join Server **by sending an **AppSKeyReq **message (backend message). The **AppSKey **is encrypted using a shared secret between the **Join Server** and the **Application Server**. The **Join Server** sends the encrypted **AppSKey**, and **DevEUI **to the Application Server in an **AppSKeyAns **message (backend message). The **Application Server** decrypts the encrypted **AppSKey,** then uses the **AppSKey **to encrypt and decrypt the application payload.

**<span style="text-decoration:underline;">After Activation:</span>**

After activation, the following additional information is stored in the end device.



*   **DevAddr **- The DevAddr is allocated by the Network Server of the end-device. It is a 32-bit device address that identifies the end-device within the current network. 
*   **FNwkSIntKey **- This is a network session key that is used by the end device to calculate the MIC or part of the MIC of all uplink data messages to ensure data integrity.
*   **SNwkSIntKey **- This is a network session key specific to the end device. It is used by the end device to verify the MIC of all downlink data messages to ensure data integrity and to compute half of the uplink messages MIC.
*   **NwkSEncKey **- This is a network session key specific to the end device. It is used to encrypt and decrypt uplink and downlink MAC commands transmitted as payload on port 0 or in the FOpt field.
*   **AppSKey **- This is an application-specific session key used by both the application server and the end device to encrypt and decrypt the payload field of application specific data messages.


## Activation By Personalization

**Activation By Personalization (ABP)** directly ties an **end-device** to a pre-selected network **by-passing** the **join procedure**. Compared with the OTAA, ABP is the less secure activation method. A join server is not involved in the ABP process.

An end device activated using the ABP method can only work with a single network and keeps the same security session for its entire lifetime.


### LoRaWAN 1.0.x

In **LoRaWAN 1.0.x**, the **DevAddr **and the two session keys **NwkSKey **and **AppSKey **are directly stored into the end-device instead of the DevEUI, AppEUI, and the AppKey. The same **DevAddr **should be stored in the **network server**. Each end device should have a unique set of **NwkSKey** and **AppSkey**. The same **NwkSKey **and **AppSKey **should be stored in the **network server** and the **application server**, respectively (see the figure below). 



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image3.png "image_tooltip")


_Figure: Pre-sharing DevAddr and two session keys for ABP._


### LoRaWAN 1.1

In **LoRaWAN 1.1**, the **DevAddr **and the four-session keys **FNwkSIntKey, SNwkSIntKey, NwkSEncKey, **and **AppSKey **are directly stored into the end-device instead of the DevEUI, JoinEUI, AppKey, and NwkKey. The same **FNwkSIntKey, SNwkSIntKey, **and **NwkSEncKey** should be stored in the **network server** and the and **AppSKey **should be stored in the **application server**. The same **DevAddr **should be stored in the **network server**. 



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image4.png "image_tooltip")



## Questions



1. _What is not a secure activation method?_
    1. _Over The Air Activation (OTAA)_
    2. **_<span style="text-decoration:underline;">Activation By Personalization (ABP)</span>_**
2. _What is the most secure activation method?_
    3. **_<span style="text-decoration:underline;">Over The Air Activation (OTAA)</span>_**
    4. _Activation By Personalization (ABP)_
3. _What security keys should be stored in an end-device for ABP in LoRaWAN 1.1?_
    5. **_<span style="text-decoration:underline;">FNwkSIntKey, SNwkSIntKey, NwkSEncKey, AppSKey</span>_**
    6. _NwkSKey, AppSKey_
    7. _JSIntKey, JSEncKey_
4. _What security keys should be stored in an end-device for ABP in LoRaWAN 1.0.x?_
    8. _FNwkSIntKey, SNwkSIntKey, NwkSEncKey, AppSKey_
    9. **_<span style="text-decoration:underline;">NwkSKey, AppSKey</span>_**
    10. _JSIntKey, JSEncKey_