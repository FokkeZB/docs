---
title: End Device Activation
section: Fundamental
---

## End Device Activation

In this chapter, you will learn how to activate and personalize an end device with a LoRaWAN network. Every end device should be registered with a network before sending and receiving messages. This registering procedure is known as **activation**. Currently, there are two activation methods available:



* **Over-The-Air-Activation (OTAA)** - Over-The-Air-Activation is the most secure activation method for end devices. This is also known as the **JOIN PROCEDURE**.
* **Activation By Personalization (ABP)** - Less secure than the OTAA and bypasses the join procedure. The end device is preprogrammed with keys and tied to a specific network.

The **join procedure** for **LoRaWAN 1.0.x** and **1.1** is slightly different. The following two sections describe the **join procedure** for **LoRaWAN 1.0.x** and **1.1** separately.


## Over The Air Activation in LoRaWAN 1.0.x

In **LoRaWAN 1.0.x**, the join procedure involves **two** **MAC messages** exchanged between the **end device** and the **network server**. They are,

*   Join-request.
*   Join-accept.

### Before Activation

Before activation, the **AppEUI**, **DevEUI**, and **AppKey** should be stored in the end device. The **AppKey** is an AES-128 bit secret key known as the **root key**. The same **AppKey** should be **provisioned** onto the **Network** where the end device is going to register. The **AppEUI** and **DevEUI** are not secret and are visible to everyone.

---
**NOTE** 

The **AppKey** is **never sent** over the network.

---

#### OTAA Message Flow

The steps below describe the message flow of the Over-The-Air-Activation (OTAA).

![alt_text](../lw-1-0-otaa-steps.png "LoRaWAN 1.0 OTAA Steps")

_Figure: Message flow for Over-The-Air-Activation (OTAA) in LoRaWAN 1.0_

##### Step 1

The **Join-request** message is always **initiated** and transmitted by the **end device**. The **Join-request** message consists of the following three fields.


* **DevEUI** – 64-bit (8-byte) globally unique end-device identifier in IEEE EUI64 address space.
* **AppEUI** – 64-bit (8-byte) globally unique identifier in IEEE EUI64 address space that uniquely identifies the **entity** able to process the **Join-request** frame. This is also known as the application identifier.
* **DevNonce** – this is a unique, random, 2-bytes value generated by the end device. The network server uses **DevNonce** to keep track of each end-device. The **DevNonce** value is used to prevent **replay attacks**. If the end device sends a **Join-request** with a previously used **DevNonce**, the network server **rejects** the **Join request** and does not allow the end device to register with the network.

The structure of the **Join-request** message is shown below.

![alt_text](../join-request-1-0.png "LoRaWAN 1.0 Join-request message")


_Figure: Join-request message in LoRaWAN 1.0.x_


The **Message Integrity Code (MIC)** is calculated over all the fields of the Join-request message using the **AppKey**.

_cmac = aes128_cmac(**AppKey**, MHDR | AppEUI | DevEUI | DevNonce)_

_MIC<sub>1</sub> = cmac[0…3]_

The calculated **Message Integrity Code (MIC)** is added to the end of the message. 

![alt_text](../join-request-1-0-phypayload.png "LoRaWAN 1.0 Join-request message PHYPayload")

_Figure: PHYPayload structure of the Join-request message_

---
**NOTE** 

* The **AppKey** is not sent with the **Join-request** message. It is used to calculate the **MIC** only.
* The **Join-request** message is **not encrypted** and sent as **plain text**.

---

The **Join-request** message can be transmitted using **any data rate** and using **one of the specified join channels**. These join channels are region-specific. For example, in Europe an end device can transmit the join-request message by randomly choosing among **868.10 MHz**, **868.30 MHz**, or **868.50 MHz**. The **Join-request** message travels through one or more gateways that simply relay the message back to the network server.

---
**NOTE** 

No response is given to the end-device if the Join-request is not accepted.

---

##### Step 2

Now the **Join-request** message has been received by the **Network Server**. If the **end device** is permitted to join with the network the network server will respond to the end device message with the **Join-accept** message.

The **Join-accept** message consists of the following fields.

* **AppNonce** – this is a random value or some form of unique ID provided by the network server. The AppNonce is used by the end device to derive the two session keys, **AppSKey** and **NwkSKey**.
* **NetID** – consists of the network ID (the 7 least significant bits) and the remaining 17 most significant bits are chosen by the network operator.
* **DevAddr** – this is the 32-bit device address assigned by the network server. Consists of NwkID and NwkAddress. The device address is unique within the current network.
* **DLSettings** – this is a 1-byte sized field consisting of downlink settings which the end device should use.
* **RxDelay** – the delay between TX and RX
* **CFList** – contains the optional list of channel frequencies to be used for the end device

The following figure shows the **Join-accept** message with all the above-generated values.

![alt_text](../join-accept-1-0.png "LoRaWAN 1.0 Join-accept message")

_Figure: Structure of the Join-accept message._


The **Message Integrity Code (MIC)** is calculated using the **AppKey** over all the fields of the **Join-accept** message as follows.

---
**NOTE** 

The **MAC Header (MHDR)** is added before calculating the **MIC**.

---

_cmac = aes128_cmac(**AppKey**, MHDR | AppNonce | NetID | DevAddr | DLSettings | RxDelay | CFList)_

_MIC = cmac[0…3]_

The calculated **MIC** is added to the end of the Join-accept message itself. The resulting frame is shown below.

![alt_text](../join-accept-1-0-phypayload.png "LoRaWAN 1.0 OTAA Steps")

The **Network Server** uses an **AES decrypt** operation in **ECB** mode to encrypt the **Join-accept** message so that the **end-device** can use an **AES encrypt** operation to decrypt the message. 

The **Join-accept** message itself is encrypted with the **AppKey** as follows.

_aes128_decrypt(**AppKey**, AppNonce | NetID | DevAddr | DLSettings | RxDelay | CFList | MIC)_


##### Step 3

The **Network Server** sends the encrypted **Join-accept** message back to the **end device**. The **Join-accept** message is sent as a normal downlink and uses the following delays to open the receive windows.

*   JOIN_ACCEPT_DELAY1 - default value is **5 seconds**
*   JOIN_ACCEPT_DELAY2 - default value is **6 seconds**


##### Step 4

The **Network Server** sends the **AppSKey** to the **Application Server**.


##### Step 5

The end device uses the **AppKey** to derive the two session keys **Network Session Key (NwkSKey)** and the **Application Session Key (AppSKey)**. The keys are calculated as follows by **decrypting** the **Join-accept** using the **AES encrypt** operation. 

_NwkSKey = aes128_encrypt(**AppKey**, 0x01 | AppNonce | NetID | DevNonce | pad_16 )_

_AppSKey = aes128_encrypt(**AppKey**, 0x02 | AppNonce | NetID | DevNonce | pad_16 )_


**<span style="text-decoration:underline;">After Activation:</span>**

After activation, the following additional information is stored in the end device.

* **DevAddr** - The DevAddr is allocated by the Network Server of the end-device. It is a 32-bit device address that identifies the end-device within the current network. 
* **NwkSKey** - The NwkSKey is used by the end device and network server to calculate and verify the Message Integrity Code (MIC) of all data messages to ensure data integrity. The NwkSKey is also used to encrypt and decrypt the payloads with MAC commands.
* **AppSKey** - The AppSKey is used to secure end-to-end communications between the end device and the application server by encrypting the payloads with application-specific data.


## Over-The-Air-Activation in LoRaWAN 1.1

In **LoRaWAN 1.1**, the join procedure involves **two MAC messages** exchanged between the **end device** and the **Join Server**. They are,

*   Join-request.
*   Join-accept.

**<span style="text-decoration:underline;">Before the activation:</span>**

Before the activation, **JoinEUI**, **DevEUI**, **AppKey**, and **NwkKey** should be stored in the end device. The **AppKey** and **NwkKey** are AES-128 bit secret keys known as **root keys**. The matching **AppKey**, **NwkKey**, and **DevEUI** should be **provisioned** onto the **Join Server** that can assist in the processing of the **Join procedure** and the session keys derivation. **JoinEUI** and **DevEUI** are **not secret** and visible to everyone.

---
**NOTE** 

The **AppKey** and **NwkKey** are never sent over the network.

---

**<span style="text-decoration:underline;">OTAA Message Flow:</span>**

The steps below describe the message flow of the Over-The-Air-Activation (OTAA).

![alt_text](../lw-1-1-otta-steps.png "LoRaWAN 1.1 OTAA steps")


_Figure: Message flow for Over-The-Air-Activation (OTAA) in LoRaWAN 1.1_


##### Step 1

The **Join-request** message is always **initiated **and transmitted by the **end device**. The **Join-request** message consists of the following three fields.



*   **DevEUI** – is a 64-bit (8-bytes) global **end-device ID** in IEEE EUI64 address space that uniquely identifies the **end-device**.
*   **JoinEUI** – is a 64-bit (8-bytes) global** application ID** in IEEE EUI64 address space that uniquely identifies the **Join Server** that can assist in the processing of the Join procedure and the session keys derivation.
*   **DevNonce** – this is a 2-bytes counter, starting at 0 when the device is initially powered up and incremented with every **Join-request**. The DevNonce value is used to prevent **replay attacks**.

---
**NOTE**

* Learning about **replay attacks** is beyond the scope of **The Things Fundamentals** certification.
* In LoRaWAN 1.1 **AppEUI** is replaced with the **JoinEUI**.
* The procedure for joining a LoRaWAN 1.0 end device with the LoRaWAN 1.1 network is also beyond the scope of The Things Fundamentals certification.
* Rejoin-request messages will be covered in The Things Advanced certification.

---

The structure of the **Join-request** message is shown in the following figure.

![alt_text](../lw-1-1-join-request.png "LoRaWAN 1.1 Join-request message")

_Figure: Fields of the join-request message in LoRaWAN 1.1_

The **Message Integrity Code (MIC)** is calculated over all the fields of the **Join-request** frame using the **NwkKey**.

_cmac = aes128_cmac(**NwkKey**, MHDR | JoinEUI | DevEUI | DevNonce)_

_MIC<sub>1</sub> = cmac[0…3]_

The calculated **Message Integrity Code (MIC)** is added to the end of the **Join-request** message. The resulting frame is known as the **PHYPayload**. 

![alt_text](../lw-1-1-join-request-phypayload.png "LoRaWAN 1.1 Join-request message PHYPayload")

_Figure: PHYPayload of the join-request message_

---
**NOTE**

* The **NwkKey** is not sent with the **Join-request** message. It is used to calculate the **MIC** only.
* The **Join-request** message is not encrypted and sent as plain text.

---

Finally, the end-device **transmits** the **Join-request** message. The Join-request message can be transmitted using **any data rate** and using **one of the specified join channels**. These join channels are region-specific, for example, in **Europe** an end device can transmit the join-request message by randomly choosing among **868.10 MHz**, **868.30 MHz**, or **868.50 MHz**. The **Join-request** message travels through one or more gateways that simply relay the message back to the network server.

---
**NOTE**

No response is given to the end-device if the Join-request is not accepted.

---

##### Step 2

The **Network Server** uses DNS to look up the IP address of the **Join Server** based on the **JoinEUI** in the received **Join-request** message.

##### Step 3

If DNS lookup succeeds, the **Network Server** sends a **JoinReq** message (backend message) to the **Join Server**. This message contains the following:

* PHYPayload of the join-request message
* MAC version
* DevEUI
* DevAddr
* DLSettings
* RxDelay
* CFList

##### Step 4

The **Join Server** processes the **Join-request** message and sends the **JoinAns** message (this is also a backend message) to the **Network Server**. If successful the **JoinAns** message contains the following:

* PHYPayload with Join-accept message
* Network session keys 
* Serving Network session integrity key (SNwkSIntKey)
* Forwarding Network session integrity key (FNwkSIntKey)
* Network session encryption key (NwkSEncKey)
* Encrypted AppSKey (network server can't read this)

The **Network Server** prepares the **Join-accept** message based on the above information.

![alt_text](../lw-1-1-join-accept.png "LoRaWAN 1.1 Join-accept message")

_Figure: PHYPayload of the Join-accept message_

The **Join-accept** message is encrypted with the **NwkKey** as follows: 

_aes128_decrypt(**NwkKey**, JoinNonce | NetID | DevAddr | DLSettings | 1623 RxDelay | CFList | MIC)._


---

**NOTE**
The **Join-accept** message itself is encrypted with the **NwkKey.** The **Join Server** uses an AES decrypt operation in ECB mode to encrypt the **join-accept** message so that the **end-device** can use an AES encrypt operation to decrypt the message. This way an end-device only has to implement AES encrypt but not AES decrypt.

---

##### Step 5

The **Network Server** forwards the received PHYPayload with the **Join-accept** message to the **end-device** if the received **JoinAns** message indicates success. The **Join-accept** message is sent as a normal downlink and uses the following delays to open the receive windows.


* JOIN_ACCEPT_DELAY1 - default value is 5 seconds
* JOIN_ACCEPT_DELAY2 - default value is 6 seconds

The **end-device** calculates the **MIC** as follows:

_cmac = aes128_cmac(**JSIntKey**, 0xFF | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList )_

_MIC = cmac[0..3]_

The **end-device** generates the **network session keys** and **AppSKey** as follows.


The **AppSKey** is derived from the **AppKey**:

* _AppSKey = aes128_encrypt(**AppKey**, 0x02 | JoinNonce | JoinEUI| DevNonce | pad_16)_


The **FNwkSIntKey**, **SNwkSIntKey**, and **NwkSEncKey** are derived from the **NwkKey**:

* _FNwkSIntKey = aes128_encrypt(**NwkKey**, 0x01 | JoinNonce | JoinEUI | DevNonce | pad_16 )_

* _SNwkSIntKey = aes128_encrypt(**NwkKey**, 0x03 | JoinNonce | JoinEUI | DevNonce | pad_16)_

* _NwkSEncKey = aes128_encrypt(**NwkKey**, 0x04 | JoinNonce | JoinEUI | DevNonce | pad_16_

##### Step 6

When the Network receives an uplink packet from the end-device, the **Network Server** will send the **DevEUI** and encrypted **AppSKey** along with the **application payload** to the **Application Server**. 

##### Step 7

When the **Application Server** receives the encrypted **AppSKey** along with the application payload, the **Application Server** will decrypt the **AppSKey** using a secret key shared between the **Join Server** and the **Application Server**, and use the **AppSKey** to decrypt the received payload. If the encrypted **AppSKey** is not made available by the **Network Server**, then the **Application Server** will proceed to **Step 8**.

##### Step 8

In this alternative step, the **Application Server** requests the **AppSKey** directly from the **Join Server**. The **Application Server** will request the **AppSKey** identified by the **DevEUI** of the end device from the **Join Server** by sending an **AppSKeyReq** message (backend message). The **AppSKey** is encrypted using a shared secret between the **Join Server** and the **Application Server**. The **Join Server** sends the encrypted **AppSKey**, and **DevEUI** to the Application Server in an **AppSKeyAns** message (backend message). The **Application Server** decrypts the encrypted **AppSKey**, then uses the **AppSKey** to encrypt and decrypt the application payload.

**<span style="text-decoration:underline;">After Activation:</span>**

After activation, the following additional information is stored in the end device.



* **DevAddr** - The DevAddr is allocated by the Network Server of the end-device. It is a 32-bit device address that identifies the end-device within the current network. 
* **FNwkSIntKey** - This is a network session key that is used by the end device to calculate the MIC or part of the MIC of all uplink data messages to ensure data integrity.
* **SNwkSIntKey** - This is a network session key specific to the end device. It is used by the end device to verify the MIC of all downlink data messages to ensure data integrity and to compute half of the uplink messages MIC.
* **NwkSEncKey** - This is a network session key specific to the end device. It is used to encrypt and decrypt uplink and downlink MAC commands transmitted as payload on port 0 or in the FOpt field.
* **AppSKey** - This is an application-specific session key used by both the application server and the end device to encrypt and decrypt the payload field of application specific data messages.


## Activation By Personalization

**Activation By Personalization (ABP)** directly ties an **end-device** to a pre-selected network **by-passing** the **JOIN PROCEDURE**. Compared with the OTAA, ABP is the less secure activation method. A join server is not involved in the ABP process.

An end device activated using the ABP method can only work with a single network and keeps the same security session for its entire lifetime.


### LoRaWAN 1.0.x

In **LoRaWAN 1.0.x**, the **DevAddr** and the two session keys **NwkSKey** and **AppSKey** are directly stored into the end-device instead of the DevEUI, AppEUI, and the AppKey. The same **DevAddr** should be stored in the **network server**. Each end device should have a unique set of **NwkSKey** and **AppSkey**. The same **NwkSKey** and **AppSKey** should be stored in the **network server** and the **application server**, respectively (see the figure below). 

![alt_text](../lw-1-0-abp.png "LoRaWAN 1.0 ABP")


_Figure: Pre-sharing DevAddr and session keys for ABP in LoRaWAN 1.0_


### LoRaWAN 1.1

In **LoRaWAN 1.1**, the **DevAddr** and the four-session keys **FNwkSIntKey**, **SNwkSIntKey**, **NwkSEncKey**, and **AppSKey** are directly stored into the end-device instead of the DevEUI, JoinEUI, AppKey, and NwkKey. The same **FNwkSIntKey**, **SNwkSIntKey**, and **NwkSEncKey** should be stored in the **network server** and the and **AppSKey** should be stored in the **application server**. The same **DevAddr** should be stored in the **network server**. 

![alt_text](../lw-1-1-abp.png "LoRaWAN 1.1 ABP")

_Figure: Pre-sharing DevAddr and session keys for ABP in LoRaWAN 1.1_


## Questions

1. What is not a secure activation method?
    - Over The Air Activation (OTAA)
    - <span style="text-decoration:underline;">Activation By Personalization (ABP)</span>
    
2. What is the most secure activation method?
    - <span style="text-decoration:underline;">Over The Air Activation (OTAA)</span>
    - Activation By Personalization (ABP)
    
3. What security keys should be stored in an end-device for ABP in LoRaWAN 1.1?
    - <span style="text-decoration:underline;">FNwkSIntKey, SNwkSIntKey, NwkSEncKey, AppSKey</span>
    - NwkSKey, AppSKey
    - JSIntKey, JSEncKey
    
4. What security keys should be stored in an end-device for ABP in LoRaWAN 1.0.x?
    - FNwkSIntKey, SNwkSIntKey, NwkSEncKey, AppSKey
    - <span style="text-decoration:underline;">NwkSKey, AppSKey</span>
    - JSIntKey, JSEncKey
